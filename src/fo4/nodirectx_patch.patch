diff --git a/src/fo4/file.rs b/src/fo4/file.rs
index 0000000..0000000 100644
--- a/src/fo4/file.rs
+++ b/src/fo4/file.rs
@@ -1,15 +1,186 @@
 use crate::{
     containers::CompressableBytes,
     derive,
     fo4::{
         ArchiveOptions, Chunk, ChunkCompressionOptions, CompressionFormat, CompressionLevel, Error,
         Format, Result,
     },
     io::Source,
     CompressionResult, Sealed,
 };
 use core::{
@@ -20,13 +191,186 @@ use core::{
     ops::{Index, IndexMut, Range, RangeBounds},
     ptr::NonNull,
     result, slice,
 };
-use directxtex::{
-    ScratchImage, TexMetadata, CP_FLAGS, DDS_FLAGS, DXGI_FORMAT, FORMAT_TYPE, TEX_DIMENSION,
-    TEX_MISC_FLAG,
-};
 use std::{error, io::Write};
 
+// ============================================================================
+// Dummy DirectXTex replacement (stubbed out for non‑Windows / no‑FFI builds)
+// ============================================================================
+
+/// Dummy representation of a DirectXTex scratch image.
+///
+/// This is a minimal stub sufficient for the code in this file to compile.
+/// It always contains empty metadata and no images.
+#[derive(Clone, Debug, Default)]
+struct ScratchImage {
+    metadata: TexMetadata,
+    images: Vec<DummyImage>,
+}
+
+#[derive(Clone, Debug, Default)]
+struct DummyImage {
+    /// Pointer to pixel data (always null in our stub).
+    pixels: *mut u8,
+    /// Size of the pixel slice (always 0 in our stub).
+    slice_pitch: usize,
+}
+
+impl ScratchImage {
+    /// Stub for `ScratchImage::load_dds` – returns an empty image.
+    #[allow(clippy::too_many_arguments)]
+    fn load_dds(
+        _bytes: &[u8],
+        _flags: DDS_FLAGS,
+        _maxsize: Option<usize>,
+        _alpha_mode: Option<()>,
+    ) -> Result<Self> {
+        Ok(Self {
+            metadata: TexMetadata::default(),
+            images: Vec::new(),
+        })
+    }
+
+    /// Return dummy metadata.
+    fn metadata(&self) -> &TexMetadata {
+        &self.metadata
+    }
+
+    /// Return an empty slice of images.
+    fn images(&self) -> &[DummyImage] {
+        &self.images
+    }
+}
+
+/// Dummy texture metadata used by this file.
+#[derive(Clone, Copy, Debug, Default)]
+struct TexMetadata {
+    width: usize,
+    height: usize,
+    depth: usize,
+    array_size: usize,
+    mip_levels: usize,
+    misc_flags: u32,
+    misc_flags2: u32,
+    format: DXGI_FORMAT,
+    dimension: TEX_DIMENSION,
+}
+
+impl TexMetadata {
+    /// Stub: no cubemaps.
+    fn is_cubemap(&self) -> bool {
+        false
+    }
+
+    /// Stub: return an empty DDS header.
+    fn encode_dds_header(&self, _flags: DDS_FLAGS) -> Result<Vec<u8>> {
+        Ok(Vec::new())
+    }
+}
+
+/// Dummy CP_FLAGS with only the constant used in this file.
+#[derive(Clone, Copy, Debug, Default)]
+struct CP_FLAGS;
+
+impl CP_FLAGS {
+    const CP_FLAGS_NONE: CP_FLAGS = CP_FLAGS;
+}
+
+/// Dummy DDS_FLAGS with only the constant used in this file.
+#[derive(Clone, Copy, Debug, Default)]
+struct DDS_FLAGS;
+
+impl DDS_FLAGS {
+    const DDS_FLAGS_NONE: DDS_FLAGS = DDS_FLAGS;
+}
+
+/// Dummy FORMAT_TYPE – only values used in this file are defined.
+#[derive(Clone, Copy, Debug)]
+enum FORMAT_TYPE {
+    FORMAT_TYPE_UNKNOWN,
+    FORMAT_TYPE_FLOAT,
+    FORMAT_TYPE_UNORM,
+    FORMAT_TYPE_SNORM,
+    FORMAT_TYPE_UINT,
+    FORMAT_TYPE_SINT,
+}
+
+impl Default for FORMAT_TYPE {
+    fn default() -> Self {
+        FORMAT_TYPE::FORMAT_TYPE_UNKNOWN
+    }
+}
+
+/// Dummy DXGI_FORMAT – only the variants matched in this file are defined.
+#[allow(non_camel_case_types)]
+#[derive(Clone, Copy, Debug)]
+enum DXGI_FORMAT {
+    DXGI_FORMAT_UNKNOWN,
+    DXGI_FORMAT_R8G8B8A8_TYPELESS,
+    DXGI_FORMAT_R8G8B8A8_UNORM,
+    DXGI_FORMAT_R8G8B8A8_UNORM_SRGB,
+    DXGI_FORMAT_R8G8B8A8_UINT,
+    DXGI_FORMAT_R8G8B8A8_SNORM,
+    DXGI_FORMAT_R8G8B8A8_SINT,
+    DXGI_FORMAT_BC1_TYPELESS,
+    DXGI_FORMAT_BC1_UNORM,
+    DXGI_FORMAT_BC1_UNORM_SRGB,
+    DXGI_FORMAT_BC2_TYPELESS,
+    DXGI_FORMAT_BC2_UNORM,
+    DXGI_FORMAT_BC2_UNORM_SRGB,
+    DXGI_FORMAT_BC3_TYPELESS,
+    DXGI_FORMAT_BC3_UNORM,
+    DXGI_FORMAT_BC3_UNORM_SRGB,
+    DXGI_FORMAT_BC4_TYPELESS,
+    DXGI_FORMAT_BC4_UNORM,
+    DXGI_FORMAT_BC4_SNORM,
+    DXGI_FORMAT_BC5_TYPELESS,
+    DXGI_FORMAT_BC5_UNORM,
+    DXGI_FORMAT_BC5_SNORM,
+    DXGI_FORMAT_BC6H_TYPELESS,
+    DXGI_FORMAT_BC6H_UF16,
+    DXGI_FORMAT_BC6H_SF16,
+    DXGI_FORMAT_BC7_TYPELESS,
+    DXGI_FORMAT_BC7_UNORM,
+    DXGI_FORMAT_BC7_UNORM_SRGB,
+}
+
+impl Default for DXGI_FORMAT {
+    fn default() -> Self {
+        DXGI_FORMAT::DXGI_FORMAT_UNKNOWN
+    }
+}
+
+impl DXGI_FORMAT {
+    /// Stub: always report non‑sRGB.
+    fn is_srgb(&self) -> bool {
+        false
+    }
+
+    /// Stub: always report unknown format type.
+    fn format_data_type(&self) -> FORMAT_TYPE {
+        FORMAT_TYPE::FORMAT_TYPE_UNKNOWN
+    }
+
+    /// Stub: always return 0 bits.
+    fn bits(&self) -> u32 {
+        0
+    }
+
+    /// Stub: compute_pitch returns a zero‑sized slice.
+    fn compute_pitch(&self, _w: usize, _h: usize, _flags: CP_FLAGS) -> Result<Pitch> {
+        Ok(Pitch { slice: 0 })
+    }
+}
+
+/// Allow `u32::from(dx10.format).into()` to compile.
+impl From<u32> for DXGI_FORMAT {
+    fn from(_value: u32) -> Self {
+        DXGI_FORMAT::DXGI_FORMAT_UNKNOWN
+    }
+}
+
+/// Dummy texture dimension enum.
+#[allow(non_camel_case_types)]
+#[derive(Clone, Copy, Debug)]
+enum TEX_DIMENSION {
+    TEX_DIMENSION_TEXTURE1D,
+    TEX_DIMENSION_TEXTURE2D,
+    TEX_DIMENSION_TEXTURE3D,
+}
+
+impl Default for TEX_DIMENSION {
+    fn default() -> Self {
+        TEX_DIMENSION::TEX_DIMENSION_TEXTURE2D
+    }
+}
+
+/// Dummy misc flag with the one constant used here.
+#[allow(non_camel_case_types)]
+#[derive(Clone, Copy, Debug)]
+enum TEX_MISC_FLAG {
+    TEX_MISC_TEXTURECUBE,
+}
+
+impl From<TEX_MISC_FLAG> for u32 {
+    fn from(_value: TEX_MISC_FLAG) -> u32 {
+        0
+    }
+}
+
+/// Dummy pitch struct returned by `compute_pitch`.
+#[derive(Clone, Copy, Debug, Default)]
+struct Pitch {
+    slice: usize,
+}
+
 /// File is at chunk capacity.
 pub struct CapacityError<'bytes>(Chunk<'bytes>);
@@ -458,7 +802,8 @@ impl<'bytes> File<'bytes> {
 
     fn make_chunks(scratch: &ScratchImage, options: &ReadOptions) -> Result<Vec<Chunk<'bytes>>> {
         let metadata = scratch.metadata();
-        let images = scratch.images();
+        // In the dummy implementation, this will always be an empty slice.
+        let images = scratch.images();
 
         let chunk_from_mips = |range: Range<usize>| -> Result<Chunk> {
             let try_clamp = |num: usize| -> Result<u16> {
@@ -557,7 +902,9 @@ impl<'bytes> File<'bytes> {
     fn read_dx10<In>(stream: &In, options: &ReadOptions) -> Result<Self>
     where
         In: ?Sized + Source<'bytes>,
     {
-        let scratch =
-            ScratchImage::load_dds(stream.as_bytes(), DDS_FLAGS::DDS_FLAGS_NONE, None, None)?;
+        // Dummy implementation: load an empty scratch image.
+        let scratch = ScratchImage::load_dds(
+            stream.as_bytes(),
+            DDS_FLAGS::DDS_FLAGS_NONE,
+            None,
+            None,
+        )?;
         let meta = scratch.metadata();
         let header: Header = DX10 {
             height: meta.height.try_into()?,
@@ -574,7 +921,11 @@ impl<'bytes> File<'bytes> {
     fn read_gnmf<In>(stream: &mut In, options: &ReadOptions) -> Result<Self>
     where
         In: ?Sized + Source<'bytes>,
     {
-        let scratch =
-            ScratchImage::load_dds(stream.as_bytes(), DDS_FLAGS::DDS_FLAGS_NONE, None, None)?;
+        let scratch = ScratchImage::load_dds(
+            stream.as_bytes(),
+            DDS_FLAGS::DDS_FLAGS_NONE,
+            None,
+            None,
+        )?;
         let metadata = scratch.metadata();
         let gnmf = {
             let mut gnmf: GNMF = metadata.try_into()?;